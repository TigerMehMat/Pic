# Библиотека Pic для PHP, v0.3&beta;

Маленькая библиотека для работы с изображениями средствами PHP

>Обратите внимание, поддерживаются только версии PHP 7.1 и старше. Если требутся рабочая версия на PHP 5.6, пишите на <admin@s-tiger.ru>.

# Функции

## Создание класса и загрузка изображения

Напомню, библиотека предназначена для работы с уже готовыми изображениями, так что создание *холстов* не предусмотрено. Загружаемое изображение указывается при вызове класса. Если изображение небыло загружено, то функция `$im->getErr()` вернет строку, иначе - `false`.

```php
<?php
	$im = new Pic('myImg.jpg');
?>
```

Всё, с изображением теперь можно работать.

## Узнать размеры

Функция возвращает массив из двух элементов (ширина и высота) или `false`, если изображение отсутствует.

```php 
<?php
	$info = $im->imageInfo();
	$w = $info[0];//Ширина
	$h = $info[1];//Высота
?>
``` 

## Изменение размера

Казалось бы, что в этой функции может быть сложного? Однако, данная библиотека создана именно для неё.

>Обратите внимание, что данная функция не возвращает измененную копию изображения, а изменяет свою.

```php
<?php
	$im->resize(новая_ширина, новая_высота[, тип_изменения, фоновый_цвет]);
?>
``` 

Если вместо ширины или высоты указать null, то она останется прежней. Это равносильно указанию параметра как `$im->imageInfo()[0]`.

Если отношение сторон изначального и конечного изображения совпадают, то проблем нет. Но что если нет? Тогда есть три варианта.

### Первый - растянуть/сжать (stretch)

Изображение растягивается или сжимается по обеим осям до нужного соотношения сторон. Самоя простая и редкоиспользуемая функция. Она, ввиду её простоты и логичности, используется по умолчанию.

```php
<?php
	$im->resize(100, 100);//Указывать тип или фоновый цвет не имеет смысла
?>
``` 

### Второй - приблизить (approx)

Изображение изменяет соотношение сторон так, что одна часть изображения вылезает, у другая располагается по всей ширине/высоте. Для такого изменения понадобится указать тип, но нет смысла изменять фоновый цвет. Фона просто нет.

```php
<?php
	$im->resize(100, 100, 'approx');//Указывать фоновый цвет не имеет смысла
?>
``` 

### Третий - наращивание (upbuild)

Изображению "наращивается" недостающее соотношение сторон. Здесь уже имеет смысл указать наращиваемый цвет. По умолчанию - белый.

```php
<?php
	$im->resize(100, 100, 'upbuild', [0, 0, 0]);
?>
``` 

>Обратите внимание, что цвет задается массивом `[$r, $g, $b]`, каждое значение в диапазоне от **0** до  **255**.

## Сохранение

Для сохранения используется функция `save`. Она имеет следующий синтаксис:

```php
<?php
	$im->save(адрес_итогового_файла[, MIME_тип, качество]);
?>
``` 
Пример:

```php
<?php
	$im->save('newfile.jpg', 'image/jpeg', 75);
?>
``` 

## Быстрое сохранение 

Допустим, вы используете библиотеку для сохранения изображения на сервер. Изображение вам надо сохранить в форматах, указанных в таблице:

Размер  |Название    |Директория|Качество|Тип обработки
--------|------------|----------|--------|-------------
оригинал|original.jpg|img/1/    |100     |stretch
100x100 |100x100.jpg |img/1/    |50      |stretch
300x300 |300x300.jpg |img/1/    |75      |approx

Вот такой код надо написать, пользуясь обычными методами:

```php
<?php
	$im = new Pic('myimg.jpg');
	$im->save('img/1/original.jpg', null, 100);
	$im1 = clone $im;
	$im1->resize(100, 100);
	$im1->save('img/1/100x100.jpg', null, 50);
	unset($im1);
	$im1 = clone $im;
	$im1->resize(300, 300, 'approx');
	$im1->save('img/1/300x300.jpg');
	unset($im1);
?>
``` 

А вот так выглядит эта же задача через функцию `qSave`:

```php 
<?php
	$im = new Pic('myimg.jpg');
	$im->qSave([
		[null, 'original.jpg', null, 100],
		[[100, 100], '100x100.jpg', null, 50],
		[[300, 300, 'approx'], '300x300.jpg']
	], 'img/1/');
?>
``` 

Синтаксис тут проще разобрать поэтапно:

```php
<?php
	$im->qSave(массив_сохранений[, директория, общий_тип]);
?>
```

Каждое сохранение в `массиве_сохранений` должно иметь формат массива следующего вида: `[[аргументы_для_resize] или null, аргументы_для_save]`, в данном случае квадратные скобки обозначают массив.

>Обратите внимание, что `директория` и аргумент пути для `save` просто склеиваются. Некорректно использовать поднятие на уровень вверх, если `директория` не пустая строка.

# Полезные советы

>Если надо работать подряд с несколькими изображениями, то можно использовать одну копию класса, а при переходе к новому изображению, загрузить его через функцию `$im->load('new.jpg')`. Старое автоматически сотрется из памяти.

>Используйте стандартные `unset` и `clone` для работы с классом. Они переопределены и работают корректно.

***

# Особенности версии

* Изображения надо указывать относитьльно выполняемого файла, указание ссылки приведет к ошибке определение MIME-типа.
* Не поддерживает прозрачность фона.
* Работает с картинками `image/jpeg`, `image/png` и `image/gif`.
